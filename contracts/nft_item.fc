#pragma version >=0.4.0;
#include "imports/stdlib.fc";
#include "imports/constants.fc";
#include "imports/utils.fc";


global int storage::init?;                     ;; is NFT initialized? (uint1)

global int storage::collection_index;          ;; index of this NFT in collection (uint32)
global slice storage::collection_address;      ;; address of NFT collection (MsgAddress)

global slice storage::owner_address;           ;; address of the NFT owner (MsgAddress)

global int storage::start_time;                ;; staking start timestamp (uint32)
global int storage::unlock_time;               ;; jettons unlock timestamp (uint32) 

global int storage::locked_value;              ;; amount of locked coins (Coins)
global int storage::claimed_rewards;           ;; claimed rewards (Coins)

global int storage::is_transferrable;          ;; does this NFT allows transfers (uint1)
global int storage::withdrawal_allowed;        ;; does this NFT allow to withdraw staked jettons? always 1 for normal pools (uint1)
global int storage::is_active;                 ;; does this NFT accept any actions with it (uint1)

global int storage::distributed_rewards;       ;; rewards that were distributed in staking pool for the time of last action with NFT (uint256)


() load_data() impure inline {
    slice ds = get_data().begin_parse();

    storage::collection_index   = ds~load_uint(32);
    storage::collection_address = ds~load_msg_addr();
    storage::init?              = 0;

    if (ds.slice_bits() > 0) {
        storage::init?               = 1;
        storage::owner_address       = ds~load_msg_addr();

        storage::start_time          = ds~load_uint(32);
        storage::unlock_time         = ds~load_uint(32);

        storage::locked_value        = ds~load_coins();
        storage::claimed_rewards     = ds~load_coins();

        storage::is_transferrable    = ds~load_uint(1);
        storage::withdrawal_allowed  = ds~load_uint(1);
        storage::is_active           = ds~load_uint(1);

        ds = ds~load_ref().begin_parse();
        storage::distributed_rewards = ds~load_uint(256);
    }
}


() save_data() impure {
    set_data(
        begin_cell()
            .store_uint(storage::collection_index, 32)
            .store_slice(storage::collection_address)
            .store_slice(storage::owner_address)
            .store_uint(storage::start_time, 32)
            .store_uint(storage::unlock_time, 32)
            .store_coins(storage::locked_value)
            .store_coins(storage::claimed_rewards)
            .store_uint(storage::is_transferrable, 1)
            .store_uint(storage::withdrawal_allowed, 1)
            .store_uint(storage::is_active, 1)
            .store_ref(
                begin_cell().store_uint(storage::distributed_rewards, 256).end_cell()
            )
            .end_cell()
    );
}

;; remains from simple NFT
() transfer_ownership(int my_balance, slice sender_address, int query_id, slice in_msg_body, int fwd_fees, int is_transferrable) impure inline { 
    throw_unless(401, equal_slices(sender_address, storage::owner_address));
    throw_unless(exc::transfer_not_allowed, (is_transferrable == 1));

    slice new_owner_address = in_msg_body~load_msg_addr();
    force_chain(new_owner_address);
    slice response_destination = in_msg_body~load_msg_addr();
    in_msg_body~load_int(1); ;; this nft don't use custom_payload
    int forward_amount = in_msg_body~load_coins();
    throw_unless(708, slice_bits(in_msg_body) >= 1);

    int rest_amount = my_balance - gas::min_tons_for_storage;
    if (forward_amount) {
        rest_amount -= (forward_amount + fwd_fees);
    }
    int need_response = response_destination.preload_uint(2) != 0; ;; if NOT addr_none: 00
    if (need_response) {
        rest_amount -= fwd_fees;
    }

    throw_unless(402, rest_amount >= 0); ;; base nft spends fixed amount of gas, will not check for response

    if (forward_amount) {
      send_msg(new_owner_address, forward_amount, op::ownership_assigned_nft, query_id, begin_cell().store_slice(storage::owner_address).store_slice(in_msg_body), 1);  ;; paying fees, revert on errors
    }
    if (need_response) {
      force_chain(response_destination);
      send_msg(response_destination, rest_amount, op::excesses, query_id, null(), 1); ;; paying fees, revert on errors
    }

    storage::owner_address = new_owner_address;
    save_data();
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    load_data();

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    if (flags & 1) { 
        if (equal_slices(sender_address, storage::collection_address)) {
            storage::is_active = 1;
            save_data();
        }
        return ();
    }

    int fwd_fee = get_forward_fee(cs);

    if (storage::init? == 0) {
        throw_unless(405, equal_slices(storage::collection_address, sender_address));
        in_msg_body~skip_bits(64);
        storage::owner_address       = in_msg_body~load_msg_addr();
        storage::start_time          = in_msg_body~load_uint(32);
        storage::unlock_time         = in_msg_body~load_uint(32);
        storage::locked_value        = in_msg_body~load_coins();
        storage::claimed_rewards     = 0;
        storage::is_transferrable    = in_msg_body~load_uint(1);
        storage::withdrawal_allowed  = in_msg_body~load_uint(1);
        storage::is_active           = 1;
        storage::distributed_rewards = in_msg_body~load_uint(256);
        
        var msg = begin_cell()
                      .store_uint(0x10, 6) 
                      .store_slice(storage::owner_address)
                      .store_coins(msg_value - gas::min_tons_for_storage)
                      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                      .store_uint(op::ownership_assigned_nft, 32)
                      .store_uint(0, 64)
                    .end_cell();
        send_raw_message(msg, 0);  ;; notify owner about mint

        save_data();
        return ();
    }

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    if (op == op::transfer_nft) {  
        transfer_ownership(my_balance, sender_address, query_id, in_msg_body, fwd_fee, storage::is_transferrable);
        return ();
    }

    if ((op == op::claim_nft) | (op == op::withdraw_nft)) {  ;; withdraw rewards or close position
        throw_unless(exc::incorrect_sender, equal_slices(storage::owner_address, sender_address));
        throw_unless(exc::already_withdrawed, (storage::is_active == 1));
        
        if (op == op::withdraw_nft) {
            throw_unless(exc::out_of_gas, msg_value >= gas::withdraw_nft);
            throw_unless(exc::not_unlocked_yet, now() >= storage::unlock_time);
        }
        else {
            throw_unless(exc::out_of_gas, msg_value >= gas::claim_nft);
        }

        cell msg_body = begin_cell()
                            .store_uint(op, 32)
                            .store_uint(query_id, 64)
                            .store_uint(storage::collection_index, 32)
                            .store_slice(storage::owner_address)
                            .store_coins(storage::locked_value)
                            .store_uint(storage::distributed_rewards, 256)
                            .store_uint(storage::withdrawal_allowed, 1)
                        .end_cell();
        builder msg = begin_cell()
                        .store_uint(0x18, 6) 
                        .store_slice(storage::collection_address)
                        .store_coins(0)
                        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                        .store_ref(msg_body);

        send_raw_message(msg.end_cell(), 64);
        storage::is_active = 0;

        save_data();
        return ();
    }

    if (op == op::change_state_nft) {  ;;  change nft state after claim
        throw_unless(exc::incorrect_sender, equal_slices(storage::collection_address, sender_address));

        storage::distributed_rewards = in_msg_body~load_uint(256);
        storage::claimed_rewards += in_msg_body~load_coins();

        ifnot (in_msg_body~load_uint(1)) {
            send_msg(storage::owner_address, 0, op::excesses, query_id, null(), 128);
            storage::owner_address = burn_address;
        }
        else {
            storage::is_active = 1;
        }
    
        save_data();
        return ();
    }

    if (op == op::get_static_data) {
        send_msg(sender_address, 0, op::report_static_data, query_id, 
                 begin_cell().store_uint(storage::collection_index, 256).store_slice(storage::collection_address), 64);  ;; carry all the remaining value of the inbound message
        return ();
    }

    if (op == op::get_storage_data) {
        int recipients_cnt = in_msg_body~load_uint(8);  ;; number of recipients
        throw_unless(exc::int_out_of_range, recipients_cnt <= 128);  ;; can send only 128 messages due to gas limits

        int computing_fees = recipients_cnt * 5400000 + 10000000;  ;; estimate gas consumed during the compute phase
        int tons_for_one_msg = (msg_value - computing_fees) / recipients_cnt; 
        throw_unless(exc::out_of_gas, tons_for_one_msg > gas::notification * 2); 

        cell forward_payload = in_msg_body~load_ref();
        cell recipients_dict = in_msg_body~load_dict();
        
        builder common = begin_cell()
                            .store_coins(tons_for_one_msg)
                            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                            .store_uint(op::report_storage_data, 32)
                            .store_uint(query_id, 64)
                            .store_slice(sender_address)
                            .store_uint(now(), 32)
                            .store_ref(get_data())
                            .store_ref(forward_payload);  ;; common part of all messages
                            
        (int key, slice to_address, int success) = recipients_dict.udict_get_min?(8);
        repeat(recipients_cnt) {
            var msg = begin_cell()
                        .store_uint(0x10, 6)
                        .store_slice(to_address)
                        .store_builder(common);

            send_raw_message(msg.end_cell(), 0);
            (key, to_address, success) = recipients_dict.udict_get_next?(8, key);
            throw_unless(success, exc::incorrect_input);
        }

        return ();
    }
    
    throw(0xffff);
}


;; GET methods

(int, int, slice, slice, cell) get_nft_data() method_id {
  load_data();
  return (storage::init?, storage::collection_index, storage::collection_address, storage::owner_address, begin_cell().end_cell());
}

(int, int, slice, slice, int, int, int, int, int, int, int) get_storage_data() method_id {
    load_data();
    return (storage::init?, storage::collection_index, storage::collection_address, storage::owner_address,
            storage::locked_value, storage::start_time, storage::unlock_time, storage::claimed_rewards,
            storage::is_transferrable, storage::is_active, storage::distributed_rewards);
}

(int) get_version() method_id {
    return 3005;
}
