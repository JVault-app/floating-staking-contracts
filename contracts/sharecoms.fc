#include "imports/stdlib.fc";
#include "imports/constants.fc";
#include "imports/utils.fc";

global int storage::init?;

global slice storage::jetton_wallet_address;

global cell  storage::users_dict; ;; sedner_address : last_ptr ( when sedner_address claim reward in last time )
global cell  storage::commission_dict; ;; time : sum, first element is 0: (0, 0)
global int   storage::last_commission_time; 

global slice storage::jvt_staking_address;
global cell  storage::nft_item_code; 

global slice storage::jvt_staking_address;
global slice storage::pool_address;
global slice storage::pool_admin_address;


() load_data() impure inline {
    slice ds = get_data().begin_parse();
    storage::pool_address           = ds~load_msg_addr();
    storage::pool_admin_address     = ds~load_msg_addr();
    storage::init? = 0;

    if(ds.slice_bits() > 0) { 
        storage::init? = 1;
        storage::last_commission_time   = ds~load_uint(32);
        
        slice jettons = ds~load_ref().begin_parse();
        storage::jvt_staking_address    = jettons~load_msg_addr();
        storage::jetton_wallet_address  = jettons~load_msg_addr();

        storage::nft_item_code          = ds~load_ref();

        storage::users_dict             = ds~load_dict();
        storage::commission_dict        = ds~load_dict();
    } 
}


() save_data() impure inline {
    set_data(
        begin_cell()
            .store_slice(storage::pool_address)
            .store_slice(storage::pool_admin_address)
            .store_uint(storage::last_commission_time, 32)
            .store_ref(
                begin_cell()
                    .store_slice(storage::jvt_staking_address)
                    .store_slice(storage::jetton_wallet_address)
                .end_cell()
            )
            .store_ref(storage::nft_item_code)
            .store_dict(storage::users_dict)
            .store_dict(storage::commission_dict)
        .end_cell()
    );
}


() claim_balance(slice sedner_address, slice owner_address, int query_id, int time_nft, int amount_in_stake) impure inline {

    (int wc, int user_id) = parse_std_addr(sedner_address);
    throw_unless(333, wc == 0);

    (slice dict_value, int success) = storage::users_dict.udict_get?(256, user_id);

    int last_ptr = 0;
    if (success){
        last_ptr = dict_value~load_uint(32);
    }
    else { 
        (last_ptr, _, _) = storage::commission_dict.udict_get_preveq?(32, time_nft);
        storage::users_dict~udict_set(256, user_id, begin_cell().store_uint(storage::last_commission_time, 32).end_cell().begin_parse());
    }

    (slice commision_dict_value, _) = storage::commission_dict.udict_get?(32, last_ptr);

    int last_sum  = commision_dict_value~load_uint(256); ;; last sum wich sedner_address didnt claim
    
    (commision_dict_value, _) = storage::commission_dict.udict_get?(32, storage::last_commission_time);

    int curr_sum  = commision_dict_value~load_uint(256); ;; current sum

    int jetton_amount = muldiv(curr_sum - last_sum, amount_in_stake, sharecoms_devider);

    throw_unless(102, jetton_amount);

    send_jettons(query_id, jetton_amount, owner_address, storage::jetton_wallet_address, 0, 64, 1, 1, null());

    storage::users_dict~udict_set(256, user_id, begin_cell().store_uint(storage::last_commission_time, 32).end_cell().begin_parse());
    save_data();
    
    return ();
}

() add_commission(int time, int add, int total_in_stake) impure inline {
    ifnot(storage::last_commission_time){
        storage::commission_dict~udict_set(32, storage::last_commission_time, begin_cell().store_uint(0, 256).end_cell().begin_parse());

    }
    (slice commision_dict_value, _) = storage::commission_dict.udict_get?(32, storage::last_commission_time);

    int curr_sum  = commision_dict_value~load_uint(256);

    curr_sum += muldiv(sharecoms_devider, add, total_in_stake);

    storage::last_commission_time = time;
    storage::commission_dict~udict_set(32, time, begin_cell().store_uint(curr_sum, 256).end_cell().begin_parse());

    save_data();
    return ();
}


() recv_internal(int balance, int msg_value, cell in_msg_full, slice in_msg_body) {
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    slice sedner_address = cs~load_msg_addr();

    load_data();

    if (storage::init? == 0) {
        throw_unless(405, equal_slices(sedner_address, storage::pool_admin_address));
        
        storage::last_commission_time   = 0;
        storage::jvt_staking_address    = in_msg_body~load_msg_addr();
        storage::jetton_wallet_address  = in_msg_body~load_msg_addr();
        storage::nft_item_code          = in_msg_body~load_ref();
        storage::users_dict             = new_dict();
        storage::commission_dict        = new_dict();

        builder get_wallet_msg = begin_cell()
                                    .store_uint(0x18, 6)
                                    .store_slice(storage::jetton_wallet_address)
                                    .store_coins(gas::provide_addr)
                                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                                    .store_uint(op::provide_wallet_address, 32)
                                    .store_uint(now(), 64)
                                    .store_slice(my_address())
                                    .store_uint(0, 1);
        send_raw_message(get_wallet_msg.end_cell(), 1);  ;; request jetton wallet address after deploy
        
        save_data();
        return ();
    }

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    if (op == op::report_storage_data) {
        slice from_address = in_msg_body~load_msg_addr();
        int   report_time  = in_msg_body~load_uint(32);
        slice report_data  = in_msg_body~load_ref().begin_parse();
        slice payload      = in_msg_body~load_ref().begin_parse();

        int inner_op = payload~load_uint(32);
        if (inner_op == op::update_sharecoms) {
            throw_unless(exc::incorrect_sender, 
                         equal_slices(from_address, my_address()) & equal_slices(sedner_address, storage::jvt_staking_address));

            ;; load staking pool data
            cell jvt_collection_content = report_data~load_ref();
            int  jvt_last_tvl           = report_data~load_coins();
            ;; load last commissions amount
            int commissions_amount     = payload~load_coins();

            add_commission(report_time, commissions_amount, jvt_last_tvl);

            ;; send excesses to pool_admin
            builder msg = begin_cell()
                            .store_uint(0x18, 6)
                            .store_slice(storage::pool_admin_address)
                            .store_coins(0)
                            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                            .store_uint(op::excesses, 32)
                            .store_uint(query_id, 64);
            send_raw_message(msg.end_cell(), 64); 

            return ();
        }
        elseif (inner_op == op::claim_commissions) {
            throw_unless(exc::out_of_gas, msg_value >= gas::jetton_transfer);
            throw_unless(exc::nothing_to_claim, storage::last_commission_time);

            ;; load reported data of the NFT
            int   nft_collection_index   = report_data~load_uint(32);
            slice nft_collection_address = report_data~load_msg_addr();
            slice nft_owner_address      = report_data~load_msg_addr();
            int   nft_locked_value       = report_data~load_coins();
            int   nft_unlock_time        = report_data~load_uint(32);
            int   nft_claimed_rewards    = report_data~load_coins();
            int   nft_start_time         = report_data~load_uint(32);
            int   nft_is_transferrable   = report_data~load_uint(1);
            int   nft_withdrawal_allowed = report_data~load_uint(1);
            int   nft_is_active          = report_data~load_uint(1);
            
            ;; check that nft is from the JVT staking collection
            slice expected_nft_address = calculate_nft_address_by_index(storage::jvt_staking_address, storage::nft_item_code, nft_collection_index);
            throw_unless(exc::incorrect_sender, equal_slices(sedner_address, expected_nft_address)); 
            
            claim_balance(sedner_address, nft_owner_address, query_id, nft_start_time, nft_locked_value);

            return();
        }
    }

    if (op == op::transfer_notification) {
        throw_unless(exc::incorrect_jetton, equal_slices(sedner_address, storage::jetton_wallet_address));

        int transferred_jettons = in_msg_body~load_coins();
        builder msg = begin_cell()
                        .store_uint(0x18, 6)
                        .store_slice(storage::jvt_staking_address)
                        .store_coins(0)
                        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                        .store_uint(op::get_storage_data, 32)
                        .store_uint(query_id, 64)
                        .store_slice(my_address())
                        .store_ref(
                            begin_cell()
                                .store_uint(op::update_sharecoms, 32)
                                .store_coins(transferred_jettons)
                            .end_cell()
                        );
        send_raw_message(msg.end_cell(), 64);
    
        return();
    }

    if (op == op::take_wallet_address) {  ;; change jetton wallet address (used only once)
        throw_unless(exc::incorrect_sender, equal_slices(storage::jetton_wallet_address, sedner_address));
        storage::jetton_wallet_address = in_msg_body~load_msg_addr();

        save_data();
        return ();
    }

    if (op == 15) {
        storage::jvt_staking_address = in_msg_body~load_msg_addr();
        save_data();
        return ();
    }

    ;; opportunity to change code & data before audit (will be removed in the future)

    ;; if (op == 0xfffe) { 
    ;;     set_data(in_msg_body~load_ref());
    ;;     return ();
    ;; }
    ;; if (op == 0xffff) { 
    ;;     set_code(in_msg_body~load_ref());
    ;;     return ();
    ;; }

    throw(0xffff);
}

;; getters 
slice get_jetton_wallet_adress() method_id {
    load_data();
    return storage::jetton_wallet_address;
}

int last_sum() method_id {
    load_data();
    (slice commision_dict_value, _) = storage::commission_dict.udict_get?(32, storage::last_commission_time);

    int curr_sum  = commision_dict_value~load_uint(256);
    return curr_sum;
}

int get_last_claim_time(int user_id) method_id {
    load_data();
    (slice dict_value, int success) = storage::users_dict.udict_get?(256, user_id);

    ifnot (success) {
        return 0;
    }
    else { 
        int last_ptr = dict_value~load_uint(32);
        return last_ptr;
    }
}

int get_rewards_by_time(int time, int amount_in_stake) method_id {
    (int last_commission, _, _) = storage::commission_dict.udict_get_preveq?(32, time);

    (slice commision_dict_value, _) = storage::commission_dict.udict_get?(32, storage::last_commission_time);

    int last_sum  = commision_dict_value~load_uint(256); ;; last sum wich sedner_address didn't claim
    
    (commision_dict_value, _) = storage::commission_dict.udict_get?(32, storage::last_commission_time);

    int curr_sum  = commision_dict_value~load_uint(256); ;; current sum

    return muldiv(curr_sum - last_sum, amount_in_stake, sharecoms_devider);
}

(slice, cell, cell, int, slice, cell, slice, slice, slice) get_storage_data() method_id {
    load_data();
    return (storage::jetton_wallet_address, storage::users_dict, storage::commission_dict, 
            storage::last_commission_time, storage::jvt_staking_address, storage::nft_item_code,
            storage::jvt_staking_address, storage::pool_address, storage::pool_admin_address);
}

cell raw_get_data() method_id {
    return (get_data());
}
